<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="BFCBFC: 块格式化上下文 作用：  防止父元素高度坍塌：overflow：hidden 防止设置flex为left的元素，与位于它旁边的元素进行叠加。给旁边的元素设置：overflow:hidden 上下两个元素同时设置了margin，导致margin进行重叠，(属于同一个BFC的两个相邻box的margin会发生重叠)，将元素设置为行块盒，display:inline-block。">
<meta property="og:type" content="article">
<meta property="og:title" content="前端常见问题">
<meta property="og:url" content="http://yoursite.com/2022/05/26/前端常见问题/index.html">
<meta property="og:site_name" content="糖茶小柚">
<meta property="og:description" content="BFCBFC: 块格式化上下文 作用：  防止父元素高度坍塌：overflow：hidden 防止设置flex为left的元素，与位于它旁边的元素进行叠加。给旁边的元素设置：overflow:hidden 上下两个元素同时设置了margin，导致margin进行重叠，(属于同一个BFC的两个相邻box的margin会发生重叠)，将元素设置为行块盒，display:inline-block。">
<meta property="og:updated_time" content="2022-05-27T02:07:52.069Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端常见问题">
<meta name="twitter:description" content="BFCBFC: 块格式化上下文 作用：  防止父元素高度坍塌：overflow：hidden 防止设置flex为left的元素，与位于它旁边的元素进行叠加。给旁边的元素设置：overflow:hidden 上下两个元素同时设置了margin，导致margin进行重叠，(属于同一个BFC的两个相邻box的margin会发生重叠)，将元素设置为行块盒，display:inline-block。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2022/05/26/前端常见问题/"/>





  <title>前端常见问题 | 糖茶小柚</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">糖茶小柚</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/05/26/前端常见问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cacute">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="糖茶小柚">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">前端常见问题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-05-26T16:00:00+08:00">
                2022-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p>BFC: 块格式化上下文</p>
<p><strong>作用：</strong></p>
<ul>
<li>防止父元素高度坍塌：overflow：hidden</li>
<li>防止设置flex为left的元素，与位于它旁边的元素进行叠加。给旁边的元素设置：overflow:hidden</li>
<li>上下两个元素同时设置了margin，导致margin进行重叠，(属于同一个BFC的两个相邻box的margin会发生重叠)，将元素设置为行块盒，display:inline-block。</li>
</ul>
<a id="more"></a>
<p><strong>形成BFC的方式：</strong></p>
<ul>
<li>float的值不是none</li>
<li>position的值是absolute、fixed</li>
<li>display的值是inline-block、flow-root、table-cell、table-caption、flex或者inline-flex、grid或者inline-grid</li>
<li>overflow的值不是visible</li>
</ul>
<h2 id="rem-em-vh-vw"><a href="#rem-em-vh-vw" class="headerlink" title="rem,em,vh,vw"></a>rem,em,vh,vw</h2><p><strong>rem:</strong> 相对于根元素 <code>&lt;html&gt;</code>进行设定，一般是根据根元素的font-size设定，常用。</p>
<p><strong>em :</strong> 相对于父元素进行设定，根据父元素的font-size。不太稳定，因为父元素会变化</p>
<p><strong>vh:</strong> 相对于视口高度进行百分比设定。</p>
<p><strong>vw:</strong> 相对于视口宽度进行百分比设定。</p>
<h2 id="JS对象的constructor属性及作用"><a href="#JS对象的constructor属性及作用" class="headerlink" title="JS对象的constructor属性及作用"></a>JS对象的constructor属性及作用</h2><p><strong>对象的constructor属性：</strong> 该属性可以返回该对象的构造函数。</p>
<p><strong>作用：</strong></p>
<ul>
<li><p>可以用constructor进行数据类型的判断</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="keyword">var</span> a =<span class="number">2</span></div><div class="line"><span class="built_in">console</span>.log(arr.constructor)  <span class="comment">//ƒ Array() &#123; [native code] &#125;</span></div><div class="line"><span class="built_in">console</span>.log(a.constructor)   <span class="comment">//ƒ Number() &#123; [native code] &#125;</span></div></pre></td></tr></table></figure>
</li>
<li><p>当对象a的构造函数A无法直接访问，但我们又想给A添加新的方法。我们就可以用 a.constructor</p>
</li>
</ul>
<p>如果想知道A有几个参数，可以直接用 a.constructor.length进行访问</p>
<p>注：a.constructor.prototype 在 chrome , firefox 中可以用 <code>a.__proto__</code>进行访问</p>
<h2 id="使用toString-方法来检测对象类型"><a href="#使用toString-方法来检测对象类型" class="headerlink" title="使用toString()方法来检测对象类型"></a>使用toString()方法来检测对象类型</h2><p>可以通过 <code>toString()</code> 来判断某个对象属于哪一种内置类型。为了每个对象都能通过 <code>Object.prototype.toString()</code> 来检测，需要以 <code>Function.prototype.call()</code> 或者 <code>Function.prototype.apply()</code> 的形式来调用，把需要检测的对象作为第一个参数传入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</div><div class="line"> </div><div class="line">toString.call(<span class="keyword">new</span> <span class="built_in">Date</span>); <span class="comment">// [object Date]</span></div><div class="line">toString.call(<span class="keyword">new</span> <span class="built_in">String</span>); <span class="comment">// [object String]</span></div><div class="line">toString.call(<span class="built_in">Math</span>); <span class="comment">// [object Math]</span></div><div class="line"> </div><div class="line"><span class="comment">//Since JavaScript 1.8.5</span></div><div class="line">toString.call(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></div><div class="line">toString.call(<span class="literal">null</span>); <span class="comment">// [object Null]</span></div></pre></td></tr></table></figure>
<h2 id="JS的同源策略"><a href="#JS的同源策略" class="headerlink" title="JS的同源策略"></a>JS的同源策略</h2><p>指一段脚本只能读取来自同一来源的窗口和文档的属性</p>
<p>原因，如果有人用iframe将真实的交易界面放到了自己的页面上，用户在交易界面输入用户名和密码的时候，他就能通过JS读取到用户的表单内容，得到用户的用户名和密码</p>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><strong>MVVM：</strong> Model-View-ViewModel的缩写，作用是将图形界面与业务逻辑，数据模型进行解耦，MVVM架构的应用程序采用了数据模型驱动界面更新的设计方案，当数据发生变化时，界面能够自动获得通知并进行更新。</p>
<p> <strong>View：</strong> 视图层，也就是用户界面。主要有html和css构成，展示ViewModel或者Model层的数据。</p>
<p><strong>Model：</strong> 是指数据模型，指后端进行各种业务逻辑处理和数据操作。</p>
<p><strong>ViewModel：</strong> 视图数据层，前端人员将从后端得到是数据转化出来，生成可以在View层使用预期的视图数据模型。能够观察到数据的变化，并对视图对应的内容进行更新。病能够监听到视图的变化，并通知数据发生变化。View和Model只能通过ViewModel进行通信。</p>
<p><strong>优点：</strong></p>
<ul>
<li>低耦合：各自可以不随其他部分的变化而变化</li>
<li>可复用：可以将一个ViewModel给多个View用</li>
<li>独立开发：开发人员可以专注与业务逻辑和数据的开发(ViewModel)，设计人员可以专注与页面设计</li>
</ul>
<h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p><strong>SPA：</strong> 单页Web应用，是加载单个HTML页面并在用户与应用程序交互时动态更新该页面的。</p>
<p><strong>优点：</strong></p>
<ul>
<li>良好的交互体验：提升页面切换体验，用户在访问页面应用是不会频繁地去切换浏览页面，从而避免了页面的重新加载。</li>
<li>前后端分离开发</li>
<li>减轻服务器的压力：服务器只用出数据即可，不用管展示逻辑和页面合成，吞吐能力会提高几倍</li>
<li>公用一套后端代码程序：不用修改后端程序代码就可以同时用于Web界面，手机，平板等多种客户端</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>SEO难度高</li>
<li>前进，后退管理：由于示在一个页面中显示所有的内容，所以不能用浏览器的前进后退功能，所有页面切换需要自己建立堆栈管理。</li>
<li>初次加载耗时多：加载亚眠时会将JS，CSS统一加载，部分页面可以在需要的时候加载，所以必须在对JS及CSS代码进行合并压缩。</li>
</ul>
<p><strong>性能优化：</strong></p>
<ul>
<li>加载优化：按需加载，提高首屏加载速度。提升初次加载速度，加快页面加载速度（采用多项缓存措施，懒加载），页面生命周期。通过构建骨架图，提前加载下个页面的雏形，再加载其余组件。</li>
<li>SEO优化：单页面应用页面不刷新，会导致我们的网页记录和内容很难被搜索引擎抓取到。解决办法：用#!代替#,谷歌会抓取。</li>
<li>前进后退功能优化：配置好路由信息，通过记录浏览过的历史路由信息，可以查看历史界面</li>
</ul>
<h2 id="Vue的单项数据流"><a href="#Vue的单项数据流" class="headerlink" title="Vue的单项数据流"></a>Vue的单项数据流</h2><p>Vue组件间传递数据是单向的，即数据总是由父组件传递到子组件，子组件在其内部可以有自己维护的数据，但它无权修改父组件传递给它的数据。</p>
<p>原因是，为了子组件间更好的解耦，当多个子组件依赖于父组件的某个数据，如果子组件修改了父组件的数据，一个子组件变化，会引发所有依赖这个数组的子组件发生变化。</p>
<h2 id="computed和watch的区别和运用的场景"><a href="#computed和watch的区别和运用的场景" class="headerlink" title="computed和watch的区别和运用的场景"></a>computed和watch的区别和运用的场景</h2><p><strong>区别：</strong></p>
<ul>
<li>watch:中的函数是不需要调用的</li>
<li>computed:内部的函数调用的时候不需要加（）</li>
<li>watch：属性监听，监听属性的变化</li>
<li>computed：计算属性通过属性计算而得来的属性。</li>
<li>watch：需要在数据变化时执行异步或开销较大的操作时使用</li>
<li>computed：对于任何复杂逻辑或一个数据属性在它所依赖的属性发生变化时，也要发生变化。</li>
<li>watch：主要用来监听某些特定数据的变化，从而进行某些业务逻辑的操作。</li>
<li>computed：属性的结果会被缓存，除非依赖的响应式属性变化才会重新结算。computed中的函数必须用return返回最终的结果。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>computed：当一个属性受多个属性影响的时候就要用到computed</li>
<li>watch：当一条数据影响多条数据的时候就需要用watch</li>
</ul>
<h2 id="Vue的父组件和子组件的生命周期和钩子函数执行顺序"><a href="#Vue的父组件和子组件的生命周期和钩子函数执行顺序" class="headerlink" title="Vue的父组件和子组件的生命周期和钩子函数执行顺序"></a>Vue的父组件和子组件的生命周期和钩子函数执行顺序</h2><p><strong>第一部分：首次加载渲染</strong></p>
<p>父 beforeCreate-&gt;父 created-&gt;父 beforeMount-&gt;子 beforeCreate -&gt; 子created -&gt; 子beforeMount -&gt;子mounted -&gt;父mounted</p>
<p><strong>第二部分：子组件更新</strong></p>
<p>父 beforeUpdate -&gt; 子beforeUpdate -&gt;子updated -&gt;父updated</p>
<p><strong>第三部分：父组件更新过程不会影响子组件</strong></p>
<p>父beforeUpdate -&gt; 父updated</p>
<p><strong>第四部分：销毁过程</strong></p>
<p>父beforeDestroy -&gt; 子beforeDestroy -&gt;子destoryed -&gt;父destroyed</p>
<h2 id="直接给一个数组项赋值，vue能检测到吗？"><a href="#直接给一个数组项赋值，vue能检测到吗？" class="headerlink" title="直接给一个数组项赋值，vue能检测到吗？"></a>直接给一个数组项赋值，vue能检测到吗？</h2><p>Vue之所以能够监听到Model状态的变化，是因为JS语言本身提供了Proxy或者Object.observe()机制来监听对象状态的变化。</p>
<p>Vue的双向绑定是通过Object.defineProperty给对象添加getter和setter方法实现的。但是不能检测对象新添加的属性，对象可以初始化的时候就设置好属性，不加新属性，数组也是对象，然而如果要求数组初始化的时候就设置好所有属性(索引)，不能新增索性(改变长度)，显然是不可能的，那么要数组也就没用了。</p>
<p>作者：井底之蛙<br>链接：<a href="https://www.zhihu.com/question/51520173/answer/335450574" target="_blank" rel="external">https://www.zhihu.com/question/51520173/answer/335450574</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>但是由于JS的限制，Vue不能检测到以下数组的变动：</p>
<ul>
<li>当利用索引直接设置一个数组项时</li>
<li>当你修改数组长度时</li>
</ul>
<p>解决第一个问题可以用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Vue.set(vm.items,indexOfItem,newVaule)</div><div class="line"></div><div class="line">vm.$set(vm.items,indexOfItem,newVaule)</div><div class="line"></div><div class="line">vm.items.splice(indexOfItem,1,newVaule)</div><div class="line"></div><div class="line">还可以不要对数组元素进行赋值，而是对其进行更新：</div><div class="line">vm.items[0].name=&quot;New name&quot;</div><div class="line">而不是</div><div class="line">vm.items[0]=&#123;</div><div class="line">	name:&apos;New name&apos;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解决第二个问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vm.items.splice(newLength)</div></pre></td></tr></table></figure>
<p>由于JavaScript的数组是可变的，可以通过 array[index] = value<br>随时添加数组项，而Object.defineProperty是针对已有项的设置，新加的项是不会被<br>Object.definePropert设置的，也就不会触发响应了。对象没影响是因为我们在创建Vue实例的时候，data中的属性是预先定义好了的。</p>
<p>所以，所谓的“由于 JavaScript 的限制”，是因为动态添加的数组项不能被劫持而产生响应。</p>
<p>实际上，Vue对数组项的操作方法（pop, push, shifut, unshift, splice, sort, reverse）做了重写，这些方法可以改变数组，而不用管某一具体的数组项了，更加灵活。</p>
<p><strong>总结</strong><br> Vue不能检测到以元素赋值方式的数组变动是因为：<br> 1、动态添加的数组项不能被劫持生成getter, setter，因此无法产生响应。<br> 2、给数组每一项做劫持，性能低且笨拙。</p>
<h2 id="Vue中父组件如何监听子组件的生命周期"><a href="#Vue中父组件如何监听子组件的生命周期" class="headerlink" title="Vue中父组件如何监听子组件的生命周期"></a>Vue中父组件如何监听子组件的生命周期</h2><ol>
<li><p>$emit</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Parent.vue</span></div><div class="line">&lt;Child @mounted=<span class="string">"changenow"</span>/&gt;</div><div class="line">changenow()&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'子组件触发了mounted'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Child.vue</span></div><div class="line">mounted()&#123;</div><div class="line">	<span class="keyword">this</span>.$emit(<span class="string">"mounted"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>@hook</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Parent.vue</span></div><div class="line">&lt;Child @hook:mounted=<span class="string">"changenow"</span>/&gt;</div><div class="line">changenow()&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'子组件触发了mounted'</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Child.vue</span></div><div class="line">mounted()&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'mounted'</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>hook源码解析</strong></p>
<p>eventsMixin方法是检查v-on监听的事件名是否以hook:开头，如果是则将对应生命同期的 <code>_hasHookEvent</code>值设置为true；</p>
<p>如果 <code>_hasHookEvent</code>为true，则会触发 <code>$emit(&#39;hook:&#39; + 对应的生命周期钩子)</code></p>
<p>链接：<a href="https://juejin.cn/post/6847902219681923080" target="_blank" rel="external">https://juejin.cn/post/6847902219681923080</a></p>
<h2 id="浏览器重绘和回流"><a href="#浏览器重绘和回流" class="headerlink" title="浏览器重绘和回流"></a>浏览器重绘和回流</h2><p><strong>重绘(repaint)：</strong> 由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局，只需要重新渲染的过程称为重绘。</p>
<p><strong>什么会引起重绘：</strong></p>
<ol>
<li>颜色改变</li>
<li>文本方向改变</li>
<li>阴影修改</li>
</ol>
<p><strong>回流(reflow)：</strong> 布局或者几何属性需要改变而需要重建的过程就称为回流，回流是影响浏览器性能的关键因素，一个元素回流可能导致其所有子元素及紧随其后的节点，祖先节点元素的随后的回流。</p>
<p><strong>回流一定会引起重绘，重绘不一定会引起回流</strong></p>
<p><strong>什么会引起回流：</strong></p>
<ol>
<li>页面初始化渲染</li>
<li>DOM结构变化，删除添加了某个节点</li>
<li>render树变化，比如减少了padding，元素位置，尺寸，内容变化</li>
<li>字体大小改变</li>
<li>窗口resize事件触发，浏览器窗口尺寸变化（回流是根据视口的大小来计算元素的位置和大小的）</li>
<li>为了获取某些属性，引发回流：比如offestTop/Left/Width/Height，scrollTop/Left….，clientTop/Left…，width,height，调节了getComputedStyle(),或者IE的currentStyle</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> s = <span class="built_in">document</span>.body.style;</div><div class="line">s.padding = <span class="string">"2px"</span>; <span class="comment">// 回流+重绘</span></div><div class="line">s.border = <span class="string">"1px solid red"</span>; <span class="comment">// 再一次 回流+重绘</span></div><div class="line">s.color = <span class="string">"blue"</span>; <span class="comment">// 再一次重绘</span></div><div class="line">s.backgroundColor = <span class="string">"#ccc"</span>; <span class="comment">// 再一次 重绘</span></div><div class="line">s.fontSize = <span class="string">"14px"</span>; <span class="comment">// 再一次 回流+重绘</span></div><div class="line"><span class="comment">// 添加node，再一次 回流+重绘</span></div><div class="line"><span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">'abc!'</span>));</div><div class="line"></div><div class="line">display:none 元素完全不陈列出来，不占据空间涉及到了DOM结构，故产生reflow与repaint。</div><div class="line">visibility：hidden指元素不可见但存在，保留空间，不影响结构，故只产生repaint</div></pre></td></tr></table></figure>
<p><strong>减少回流：</strong></p>
<ol>
<li>避免逐项更改样式。最好一次性更改style属性，或者将样式列表定义为class并一次性更改class属性。</li>
<li>避免设置多项内联样式。</li>
<li>避免循环操作DOM，创建一个documentFrgment或div在它上面应用所有的DOM操作，最后再把它添加到window.document。</li>
<li>避免多次读取offsetLeft等属性，无法避免则将它们缓存到变量，用js操作后，再将新值放到DOM里。</li>
<li>将复杂元素，如复杂的动画，使用绝对定位或固定定位，使它脱离文档流，负责回流代价十分高。</li>
<li>应用元素的动画，使用position属性的fixed值或absolute的值</li>
<li>避免使用table布局，table中每个元素的发小以及内容改变，都会导致整个table重新计算。</li>
<li>使用css3硬件加速，可以让transform，opacity,filters这些动画不会引起回流重绘</li>
<li>避免使用CSS的javascript表达式</li>
<li>离线模式，将display:none 然后再对其进行各样的操作，最后再将display改变回来</li>
</ol>
<p><strong>浏览器优化机制</strong></p>
<p>1.由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重拍过程。浏览器会将修改操作放入到队列里，知道过了一段时间或者操作达到了一个阈值，才会清空队列。</p>
<p>当获取布局信息的操作时，会强制队列刷新，包括前面讲到的offsetTop等方法都会返回最新的数据</p>
<p>因此浏览器不得不清空队列，触发回流重绘来返回正确的值</p>
<p>参考：<a href="https://vue3js.cn/interview/css/layout_painting.html#%E4%BA%8C%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%A6%E5%8F%91" target="_blank" rel="external">面试官：怎么理解回流跟重绘？什么场景下会触发？ | web前端面试 - 面试官系列 (vue3js.cn)</a></p>
<h2 id="vue实现数据双向绑定"><a href="#vue实现数据双向绑定" class="headerlink" title="vue实现数据双向绑定"></a>vue实现数据双向绑定</h2><p>vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调来渲染视图。</p>
<p>两个方面：</p>
<ul>
<li>视图变化更新数据：可直接用事件监听</li>
<li>数据变化更新视图：</li>
</ul>
<ol>
<li>实现一个数据监听器 Observer：需要observer(观察者)对数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter<br>这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li>
<li>实现一个指令解析器 Compile ：compile(模板解析器)解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>
<li>实现一个订阅者 Watcher ：Watcher(订阅者)是Observer和Compile之间通信的桥梁，主要做的事情是:<br>1、在自身实例化时往属性订阅器(dep)里面添加自己<br>2、自身必须有一个update()方法<br>3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li>
<li><p>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</p>
<p>原文链接：<a href="https://blog.csdn.net/weixin_58032613/article/details/122735346" target="_blank" rel="external">https://blog.csdn.net/weixin_58032613/article/details/122735346</a></p>
</li>
</ol>
<h2 id="虚拟DOM的优缺点"><a href="#虚拟DOM的优缺点" class="headerlink" title="虚拟DOM的优缺点"></a>虚拟DOM的优缺点</h2><p><strong>优点：</strong></p>
<ul>
<li>保证性能下限：虚拟DOM可以经过diff找出最小差异，然后进行patch,这种操作虽然比不上手动优化，但是比起粗暴的DOM操作性能要好得多</li>
<li>无需手动操作DOM：虚拟DOM的diff和patch都是在一次更新中自动进行的，我们无需手动操作DOM</li>
<li>跨平台：虚拟DOM本质上是JS对象，而DOM与平台强相关，相比之下虚拟DOM可以进行更方便的跨平台操作</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>无法进行极致优化：在一些性能要求较高的应用中虚拟DOM无法进行针对性的极致优化</li>
</ul>
<p><strong>虚拟DOM实现原理：</strong></p>
<p>用JS对象模拟真实DOM树，对真实DOM进行抽象</p>
<p>diff算法——比较两颗虚拟DOM树的差异</p>
<p>pach算法——将两个虚拟DOM对象的差异应用到真正的DOM树</p>
<h2 id="对于vue3-0特性你有什么了解吗？"><a href="#对于vue3-0特性你有什么了解吗？" class="headerlink" title="对于vue3.0特性你有什么了解吗？"></a>对于vue3.0特性你有什么了解吗？</h2><ol>
<li>监测机制的改变</li>
<li>模板</li>
<li>对象式的组件声明方式</li>
<li>支持自定义渲染器，支持Fragment(多个根节点)和Protal(在dom其他部分渲染组建内容)组件，基于treeshaking优化等</li>
</ol>
<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p><strong>浅拷贝是拷贝一层，只复制属性指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存，修改对象属性会影响原对象</strong></p>
<p><strong>如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址。</strong></p>
<p>浅拷贝有：</p>
<ul>
<li>Object.assign</li>
<li>Arrary.prototype.slice()，Arrary.prototype.concat()</li>
<li>使用拓展运算符实现的复制 如 …</li>
</ul>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p><strong>深拷贝开辟一个新的栈，两个对象属性完全相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性</strong></p>
<p>深拷贝有：</p>
<ul>
<li><p>_.cloneDeep()<br>vue中使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">1.安装：</div><div class="line">npm i --save lodash</div><div class="line"></div><div class="line">2.在main.js中引入：</div><div class="line">import _ from &apos;lodash&apos;</div><div class="line">Vue.prototype._=_</div><div class="line"></div><div class="line">3.使用</div><div class="line">let newObj = this._.cloneDeep(oldObj)</div></pre></td></tr></table></figure>
</li>
<li><p>jQuery.extend()</p>
</li>
<li>JSON.stringify()，JSON.parse()</li>
<li>手写循环递归</li>
</ul>
<p>参考博客：<a href="https://zhuanlan.zhihu.com/p/356593113" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/356593113</a></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p><strong>闭包可以在一个内层函数中访问到其外层函数的作用域</strong></p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p><strong>作用域是变量和函数生效的区域或集合</strong></p>
<p>作用域分为：</p>
<ul>
<li>全局作用域：任何不在函数中或是大括号里声明的变量，都是在全局作用域中，全局作用域下的变量可以在任意位置访问</li>
<li>函数作用域：也叫局部作用域，变量示在函数内部声明的，这些变量只能在函数内部访问。</li>
<li>块级作用域：大括号，用let，const声明的变量存在于块级作用域中。</li>
</ul>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p><strong>又叫静态作用域，变量被创建时就确定好了，而非执行阶段确定的。JS遵循词法作用域。</strong></p>
<h3 id="作用域链-1"><a href="#作用域链-1" class="headerlink" title="作用域链"></a>作用域链</h3><p><strong>在JS中使用一个变量时，先会在当前作用域下去寻找改变量，如果没找到，再到它的上层作用域寻找，直至找到该变量。</strong></p>
<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><p><strong>执行上下文是对JS代码执行环境的抽象概念</strong></p>
<p>三种类型:</p>
<ul>
<li>全局执行上下文：只有一个，浏览器中的全局对象就是window对象</li>
<li>函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会被创建一个新的执行上下文</li>
<li>Eval函数执行上下文：指运行在eval函数中的代码，很少用而且不建议使用</li>
</ul>
<p><strong>生命周期</strong>：</p>
<ol>
<li>创建阶段<br>函数被调用，但未执行任何其内部代码之前<ul>
<li>确定this的值，也叫做this.Binding</li>
<li>LexicalEnvironment(词法环境) 组件被创建</li>
<li>VariableEnvironment(变量环境) 组件被创建</li>
</ul>
</li>
<li>执行阶段<br>执行变量赋值，代码执行</li>
<li>回收阶段<br>执行上下文出栈等待虚拟机回收执行上下文</li>
</ol>
<p><strong>执行栈(调用栈)</strong></p>
<p>用于存储在代码执行期间创建的所有执行上下文</p>
<p>当 <code>Javascript</code>引擎开始执行你第一行脚本代码的时候，它就会创建一个全局执行上下文然后将它压到执行栈中</p>
<p>每当引擎碰到一个函数的时候，它就会创建一个函数执行上下文，然后将这个执行上下文压到执行栈中</p>
<p>引擎会执行位于执行栈栈顶的执行上下文(一般是函数执行上下文)，当该函数执行结束后，对应的执行上下文就会被弹出，然后控制流程到达执行栈的下一个执行上下文</p>
<p><strong>持续更新中……</strong></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/05/26/刷题/" rel="next" title="刷题">
                <i class="fa fa-chevron-left"></i> 刷题
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="cacute" />
          <p class="site-author-name" itemprop="name">cacute</p>
           
              <p class="site-description motion-element" itemprop="description">人生得意须尽欢，莫使金樽空对月</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">15</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#BFC"><span class="nav-number">1.</span> <span class="nav-text">BFC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#rem-em-vh-vw"><span class="nav-number">2.</span> <span class="nav-text">rem,em,vh,vw</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS对象的constructor属性及作用"><span class="nav-number">3.</span> <span class="nav-text">JS对象的constructor属性及作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用toString-方法来检测对象类型"><span class="nav-number">4.</span> <span class="nav-text">使用toString()方法来检测对象类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JS的同源策略"><span class="nav-number">5.</span> <span class="nav-text">JS的同源策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVVM"><span class="nav-number">6.</span> <span class="nav-text">MVVM</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SPA"><span class="nav-number">7.</span> <span class="nav-text">SPA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue的单项数据流"><span class="nav-number">8.</span> <span class="nav-text">Vue的单项数据流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#computed和watch的区别和运用的场景"><span class="nav-number">9.</span> <span class="nav-text">computed和watch的区别和运用的场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue的父组件和子组件的生命周期和钩子函数执行顺序"><span class="nav-number">10.</span> <span class="nav-text">Vue的父组件和子组件的生命周期和钩子函数执行顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#直接给一个数组项赋值，vue能检测到吗？"><span class="nav-number">11.</span> <span class="nav-text">直接给一个数组项赋值，vue能检测到吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vue中父组件如何监听子组件的生命周期"><span class="nav-number">12.</span> <span class="nav-text">Vue中父组件如何监听子组件的生命周期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器重绘和回流"><span class="nav-number">13.</span> <span class="nav-text">浏览器重绘和回流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vue实现数据双向绑定"><span class="nav-number">14.</span> <span class="nav-text">vue实现数据双向绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#虚拟DOM的优缺点"><span class="nav-number">15.</span> <span class="nav-text">虚拟DOM的优缺点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#对于vue3-0特性你有什么了解吗？"><span class="nav-number">16.</span> <span class="nav-text">对于vue3.0特性你有什么了解吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#深拷贝与浅拷贝"><span class="nav-number">17.</span> <span class="nav-text">深拷贝与浅拷贝</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#浅拷贝"><span class="nav-number">17.1.</span> <span class="nav-text">浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#深拷贝"><span class="nav-number">17.2.</span> <span class="nav-text">深拷贝</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#闭包"><span class="nav-number">18.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#作用域链"><span class="nav-number">19.</span> <span class="nav-text">作用域链</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域"><span class="nav-number">19.1.</span> <span class="nav-text">作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#词法作用域"><span class="nav-number">19.2.</span> <span class="nav-text">词法作用域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作用域链-1"><span class="nav-number">19.3.</span> <span class="nav-text">作用域链</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行上下文"><span class="nav-number">20.</span> <span class="nav-text">执行上下文</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cacute</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
